C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CDC
OBJECT MODULE PLACED IN .\Objects\CDC.obj
COMPILER INVOKED BY: E:\Keil_C51\C51\BIN\C51.EXE CDC.C LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Public) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\CDC.lst) TABS(2) OBJECT(.\Objects\CDC.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2          * File Name          : CDC.C
   3          * Author             : WCH
   4          * Version            : V1.0
   5          * Date               : 2017/03/01
   6          * Description        : CH554×öCDCÉè±¸×ª´®¿Ú£¬Ñ¡Ôñ´®¿Ú1
   7          *******************************************************************************/
   8          #include "CH554.H"
   9          #include "DEBUG.H"
  10          #include <stdio.h>
  11          #include <string.h>
  12          #define THIS_ENDP0_SIZE         DEFAULT_ENDP0_SIZE 
  13          UINT8X  Ep0Buffer[THIS_ENDP0_SIZE] _at_ 0x0000;                                //¶Ëµã0 OUT&IN»º³åÇø£¬±ØÐëÊÇ
             -Å¼µØÖ·
  14          UINT8X  Ep2Buffer[2*MAX_PACKET_SIZE] _at_ 0x0008;                              //¶Ëµã2 IN&OUT»º³åÇø,±ØÐëÊÇÅ
             -¼µØÖ·
  15          UINT8X  Ep1Buffer[MAX_PACKET_SIZE] _at_ 0x00a0;
  16          
  17          UINT16 SetupLen,ControlData;
  18          UINT8   SetupReq,Count,UsbConfig,down=0;
  19          UINT8   RTS_DTR=0;
  20          UINT8   baudFlag0,baudFlag1,baudFlag2=0;
  21          UINT8   baud0,baud1;
  22          UINT8   num = 0;
  23          PUINT8  pDescr;                                                                //USBÅäÖÃ±êÖ¾
  24          USB_SETUP_REQ   SetupReqBuf;                                                   //ÔÝ´æSetup°ü
  25          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)
  26          
  27          #define  SET_LINE_CODING                0X20            // Configures DTE rate, stop-bits, parity, and num
             -ber-of-character
  28          #define  GET_LINE_CODING                0X21            // This request allows the host to find out the cu
             -rrently configured line coding.
  29          #define  SET_CONTROL_LINE_STATE         0X22            // This request generates RS-232/V.24 style contro
             -l signals.
  30          
  31          
  32          /*Éè±¸ÃèÊö·û*/
  33          /*
  34          UINT8C DevDesc[] = {0x12,0x01,0x10,0x01,0x02,0x00,0x00,DEFAULT_ENDP0_SIZE,
  35                              0x86,0x1a,0x22,0x57,0x00,0x01,0x01,0x02,
  36                              0x03,0x01
  37                             };
  38          UINT8C CfgDesc[] ={
  39              0x09,0x02,0x43,0x00,0x02,0x01,0x00,0xa0,0x32,             //ÅäÖÃÃèÊö·û£¨Á½¸ö½Ó¿Ú£©
  40            //ÒÔÏÂÎª½Ó¿Ú0£¨CDC½Ó¿Ú£©ÃèÊö·û  
  41              0x09,0x04,0x00,0x00,0x01,0x02,0x02,0x01,0x00,             //CDC½Ó¿ÚÃèÊö·û(Ò»¸ö¶Ëµã)
  42            //ÒÔÏÂÎª¹¦ÄÜÃèÊö·û
  43              0x05,0x24,0x00,0x10,0x01,                                 //¹¦ÄÜÃèÊö·û(Í·)
  44            0x05,0x24,0x01,0x00,0x00,                                 //¹ÜÀíÃèÊö·û(Ã»ÓÐÊý¾ÝÀà½Ó¿Ú) 03 01
  45            0x04,0x24,0x02,0x02,                                      //Ö§³ÖSet_Line_Coding¡¢Set_Control_Line_State¡¢
             -Get_Line_Coding¡¢Serial_State 
  46            0x05,0x24,0x06,0x00,0x01,                                 //±àºÅÎª0µÄCDC½Ó¿Ú;±àºÅ1µÄÊý¾ÝÀà½Ó¿Ú
  47            0x07,0x05,0x81,0x03,0x08,0x00,0xFF,                       //ÖÐ¶ÏÉÏ´«¶ËµãÃèÊö·û
  48            //ÒÔÏÂÎª½Ó¿Ú1£¨Êý¾Ý½Ó¿Ú£©ÃèÊö·û
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 2   

  49            0x09,0x04,0x01,0x00,0x02,0x0a,0x00,0x00,0x00,             //Êý¾Ý½Ó¿ÚÃèÊö·û
  50              0x07,0x05,0x02,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û  
  51            0x07,0x05,0x82,0x02,0x40,0x00,0x00,                       //¶ËµãÃèÊö·û
  52          };*/
  53          
  54          
  55          /*
  56          UINT8C DevDesc[18]={0x12,0x01,0x10,0x01,0xff,0x00,0x02,0x08,                   //Éè±¸ÃèÊö·û
  57                              0x86,0x1a,0x23,0x55,0x04,0x03,0x00,0x00,
  58                              0x00,0x01};*/
  59          UINT8C DevDesc[18]={0x12,0x01,0x10,0x01,0xff,0x00,0x00,0x08,                   //Éè±¸ÃèÊö·û
  60                              0x86,0x1a,0x23,0x75,0x63,0x02,0x00,0x02,
  61                              0x00,0x01};
  62          /*
  63          UINT8C CfgDesc[39]={0x09,0x02,0x27,0x00,0x01,0x01,0x00,0x80,0xf0,              //ÅäÖÃÃèÊö·û£¬½Ó¿ÚÃèÊö·û,¶Ë
             -µãÃèÊö·û
  64                              0x09,0x04,0x00,0x00,0x03,0xff,0x01,0x02,0x00,           
  65                              0x07,0x05,0x82,0x02,0x20,0x00,0x00,                        //ÅúÁ¿ÉÏ´«¶Ëµã
  66                              0x07,0x05,0x02,0x02,0x20,0x00,0x00,                        //ÅúÁ¿ÏÂ´«¶Ëµã      
  67                              0x07,0x05,0x81,0x03,0x08,0x00,0x01};                       //ÖÐ¶ÏÉÏ´«¶Ëµã*/
  68                              
  69          UINT8C CfgDesc[39]={0x09,0x02,0x27,0x00,0x01,0x01,0x00,0x80,0xf0,              //ÅäÖÃÃèÊö·û£¬½Ó¿ÚÃèÊö·û,¶Ë
             -µãÃèÊö·û
  70                              0x09,0x04,0x00,0x00,0x03,0xff,0x01,0x02,0x00,           
  71                              0x07,0x05,0x82,0x02,0x20,0x00,0x00,                        //ÅúÁ¿ÉÏ´«¶Ëµã
  72                              0x07,0x05,0x02,0x02,0x20,0x00,0x00,                        //ÅúÁ¿ÏÂ´«¶Ëµã      
  73                              0x07,0x05,0x81,0x03,0x08,0x00,0x01};                       //ÖÐ¶ÏÉÏ´«¶Ë
  74          
  75          UINT8C DataBuf[26]={0x30,0x00,0xc3,0x00,0xff,0xec,0x9f,0xec,0xff,0xec,0xdf,0xec,
  76                              0xdf,0xec,0xdf,0xec,0x9f,0xec,0x9f,0xec,0x9f,0xec,0x9f,0xec,
  77                              0xff,0xec};
  78          
  79          
  80          UINT8X UserEp2Buf[64];                                            //ÓÃ»§Êý¾Ý¶¨Òå
  81          
  82          /*×Ö·û´®ÃèÊö·û*/
  83                              /*
  84           unsigned char  code LangDes[]={0x04,0x03,0x09,0x04};           //ÓïÑÔÃèÊö·û
  85           unsigned char  code SerDes[]={                                 //ÐòÁÐºÅ×Ö·û´®ÃèÊö·û
  86                          0x14,0x03,
  87                  0x32,0x00,0x30,0x00,0x31,0x00,0x37,0x00,0x2D,0x00,
  88                  0x32,0x00,0x2D,0x00,
  89                  0x32,0x00,0x35,0x00
  90                          };     
  91           unsigned char  code Prod_Des[]={                                //²úÆ·×Ö·û´®ÃèÊö·û
  92                  0x14,0x03,
  93                  0x43,0x00,0x48,0x00,0x35,0x00,0x35,0x00,0x34,0x00,0x5F,0x00,
  94                  0x43,0x00,0x44,0x00,0x43,0x00,
  95           };
  96           unsigned char  code Manuf_Des[]={  
  97                  0x0A,0x03,
  98                  0x5F,0x6c,0xCF,0x82,0x81,0x6c,0x52,0x60,
  99           };*/
 100          
 101          //cdc²ÎÊý
 102          UINT8X LineCoding[7]={0x00,0xe1,0x00,0x00,0x00,0x00,0x08};   //³õÊ¼»¯²¨ÌØÂÊÎª57600£¬1Í£Ö¹Î»£¬ÎÞÐ£Ñé£¬8Êý¾Ý
             -Î»¡£
 103          
 104          #define UART_REV_LEN  64                 //´®¿Ú½ÓÊÕ»º³åÇø´óÐ¡
 105          UINT8I Receive_Uart_Buf[UART_REV_LEN];   //´®¿Ú½ÓÊÕ»º³åÇø
 106          volatile UINT8I Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÐ´ÈëÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
 107          volatile UINT8I Uart_Output_Point = 0;  //Ñ­»·»º³åÇøÈ¡³öÖ¸Õë£¬×ÜÏß¸´Î»ÐèÒª³õÊ¼»¯Îª0
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 3   

 108          volatile UINT8I UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 109          
 110          
 111          volatile UINT8I USBByteCount = 0;      //´ú±íUSB¶Ëµã½ÓÊÕµ½µÄÊý¾Ý
 112          volatile UINT8I USBBufOutPoint = 0;    //È¡Êý¾ÝÖ¸Õë
 113          
 114          volatile UINT8I UpPoint2_Busy  = 0;   //ÉÏ´«¶ËµãÊÇ·ñÃ¦±êÖ¾
 115          
 116          
 117          /*******************************************************************************
 118          * Function Name  : USBDeviceCfg()
 119          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ
 120          * Input          : None
 121          * Output         : None
 122          * Return         : None
 123          *******************************************************************************/
 124          void USBDeviceCfg()
 125          {
 126   1          USB_CTRL = 0x00;                                                           //Çå¿ÕUSB¿ØÖÆ¼Ä´æÆ÷
 127   1          USB_CTRL &= ~bUC_HOST_MODE;                                                //¸ÃÎ»ÎªÑ¡ÔñÉè±¸Ä£Ê½
 128   1          USB_CTRL |=  bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                    //USBÉè±¸ºÍÄÚ²¿ÉÏÀ­Ê¹ÄÜ,ÔÚÖ
             -Ð¶ÏÆÚ¼äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô¶¯·µ»ØNAK
 129   1          USB_DEV_AD = 0x00;                                                         //Éè±¸µØÖ·³õÊ¼»¯
 130   1      //     USB_CTRL |= bUC_LOW_SPEED;
 131   1      //     UDEV_CTRL |= bUD_LOW_SPEED;                                                //Ñ¡ÔñµÍËÙ1.5MÄ£Ê½
 132   1          USB_CTRL &= ~bUC_LOW_SPEED;
 133   1          UDEV_CTRL &= ~bUD_LOW_SPEED;                                             //Ñ¡ÔñÈ«ËÙ12MÄ£Ê½£¬Ä¬ÈÏ·½Ê½
 134   1          UDEV_CTRL = bUD_PD_DIS;  // ½ûÖ¹DP/DMÏÂÀ­µç×è
 135   1          UDEV_CTRL |= bUD_PORT_EN;                                                  //Ê¹ÄÜÎïÀí¶Ë¿Ú
 136   1      }
 137          /*******************************************************************************
 138          * Function Name  : USBDeviceIntCfg()
 139          * Description    : USBÉè±¸Ä£Ê½ÖÐ¶Ï³õÊ¼»¯
 140          * Input          : None
 141          * Output         : None
 142          * Return         : None
 143          *******************************************************************************/
 144          void USBDeviceIntCfg()
 145          {
 146   1          USB_INT_EN |= bUIE_SUSPEND;                                               //Ê¹ÄÜÉè±¸¹ÒÆðÖÐ¶Ï
 147   1          USB_INT_EN |= bUIE_TRANSFER;                                              //Ê¹ÄÜUSB´«ÊäÍê³ÉÖÐ¶Ï
 148   1          USB_INT_EN |= bUIE_BUS_RST;                                               //Ê¹ÄÜÉè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶
             -Ï
 149   1          USB_INT_FG |= 0x1F;                                                       //ÇåÖÐ¶Ï±êÖ¾
 150   1          IE_USB = 1;                                                               //Ê¹ÄÜUSBÖÐ¶Ï
 151   1          EA = 1;                                                                   //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï
 152   1      }
 153          /*******************************************************************************
 154          * Function Name  : USBDeviceEndPointCfg()
 155          * Description    : USBÉè±¸Ä£Ê½¶ËµãÅäÖÃ£¬Ä£Äâ¼æÈÝHIDÉè±¸£¬³ýÁË¶Ëµã0µÄ¿ØÖÆ´«Êä£¬»¹°üÀ¨¶Ëµã2ÅúÁ¿ÉÏÏÂ´«
 156          * Input          : None
 157          * Output         : None
 158          * Return         : None
 159          *******************************************************************************/
 160          void USBDeviceEndPointCfg()
 161          {
 162   1        UEP1_DMA = Ep1Buffer;                                                      //¶Ëµã1 ·¢ËÍÊý¾Ý´«ÊäµØÖ·
 163   1          UEP2_DMA = Ep2Buffer;                                                      //¶Ëµã2 INÊý¾Ý´«ÊäµØÖ· 
 164   1          UEP2_3_MOD = 0xCC;                                                         //¶Ëµã2/3 µ¥»º³åÊÕ·¢Ê¹ÄÜ
 165   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;                 //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK£¬OUT·µ»ØACK
 166   1      
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 4   

 167   1          UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 //¶Ëµã1×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬
             -INÊÂÎñ·µ»ØNAK  
 168   1        UEP0_DMA = Ep0Buffer;                                                      //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 169   1          UEP4_1_MOD = 0X40;                                                         //¶Ëµã1ÉÏ´«»º³åÇø£»¶Ëµã0µ¥6
             -4×Ö½ÚÊÕ·¢»º³åÇø
 170   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 //ÊÖ¶¯·­×ª£¬OUTÊÂÎñ·µ»ØACK£
             -¬INÊÂÎñ·µ»ØNAK
 171   1      }
 172          /*******************************************************************************
 173          * Function Name  : Config_Uart1(UINT8 *cfg_uart)
 174          * Description    : ÅäÖÃ´®¿Ú1²ÎÊý
 175          * Input          : ´®¿ÚÅäÖÃ²ÎÊý ËÄÎ»²¨ÌØÂÊ¡¢Í£Ö¹Î»¡¢Ð£Ñé¡¢Êý¾ÝÎ»
 176          * Output         : None
 177          * Return         : None
 178          *******************************************************************************/
 179          void Config_Uart1(UINT8 *cfg_uart)
 180          {
 181   1        UINT32 uart1_buad = 0;
 182   1        *((UINT8 *)&uart1_buad) = cfg_uart[3];
 183   1        *((UINT8 *)&uart1_buad+1) = cfg_uart[2];
 184   1        *((UINT8 *)&uart1_buad+2) = cfg_uart[1];
 185   1        *((UINT8 *)&uart1_buad+3) = cfg_uart[0];
 186   1        IE_UART1 = 0;
 187   1        SBAUD1 = 0 - FREQ_SYS/16/uart1_buad;
 188   1        IE_UART1 = 1;
 189   1      }
 190          /*******************************************************************************
 191          * Function Name  : DeviceInterrupt()
 192          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 193          *******************************************************************************/
 194          void    DeviceInterrupt( void ) interrupt INT_NO_USB using 1                    //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä´æ
             -Æ÷×é1
 195          {
 196   1          
 197   1          UINT8 len,i;
 198   1          if(UIF_TRANSFER)                                                            //USB´«ÊäÍê³É±êÖ¾
 199   1          {
 200   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 201   2              {
 202   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ¶ËµãÅúÁ¿ÉÏ´«
 203   3                   UEP2_T_LEN = 0;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 204   3      //            UEP1_CTRL ^= bUEP_T_TOG;                                          //Èç¹û²»ÉèÖÃ×Ô¶¯·­×ªÔòÐèÒª
             -ÊÖ¶¯·­×ª
 205   3                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 206   3                  UpPoint2_Busy = 0;// not  busy
 207   3                  break;
 208   3              case UIS_TOKEN_OUT | 2:                                                 //endpoint 2# ¶ËµãÅúÁ¿ÏÂ´«
 209   3                  if ( U_TOG_OK )                                                     // ²»Í¬²½µÄÊý¾Ý°ü½«¶ªÆú
 210   3                  {
 211   4                      len = USB_RX_LEN;
 212   4                      USBByteCount = USB_RX_LEN;
 213   4                      USBBufOutPoint = 0;
 214   4                      UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_NAK;
 215   4                      
 216   4                  }
 217   3                  break;
 218   3              case UIS_TOKEN_SETUP | 0:                                               //SETUPÊÂÎñ
 219   3                  len = USB_RX_LEN;
 220   3                  if(len == (sizeof(USB_SETUP_REQ)))
 221   3                  {
 222   4                      SetupLen = UsbSetupBuf->wLengthL;
 223   4                      RTS_DTR = UsbSetupBuf->wValueL;
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 5   

 224   4                      if(UsbSetupBuf->wLengthH || SetupLen > 0x7F )
 225   4                      {
 226   5                          SetupLen = 0x7F;                                             // ÏÞÖÆ×Ü³¤¶È
 227   5                      }
 228   4                      len = 0;                                                         // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶
             -È
 229   4                      SetupReq = UsbSetupBuf->bRequest;             
 230   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD ){/*HIDÀàÃüÁ
             -î*/
 231   5                          switch( SetupReq )                                             
 232   5                          {
 233   6                              case 0xC0:                                                  
 234   6                                  pDescr = &DataBuf[num];
 235   6                                  len = 2;
 236   6                                  if(num<24){ 
 237   7                                      num += 2;
 238   7                                  }else{
 239   7                                      num = 24;
 240   7                                  }                     
 241   6                                  break;
 242   6                              case 0x40:
 243   6                                  len = 9;   //±£Ö¤×´Ì¬½×¶Î£¬ÕâÀïÖ»Òª±È8´ó£¬ÇÒ²»µÈÓÚ0xff¼´¿É
 244   6                                  break;
 245   6                              case 0xa4:
 246   6                                  switch(RTS_DTR){
 247   7                                      case 0x9f://RTS->LOW, DTR->LOW
 248   7                                        P1 &= ~0x10; //RTS LOW
 249   7                                        P1 &= ~0x20; //DTR LOW
 250   7                                        break;
 251   7                                      case 0xdf://RTS->HIGH,DTR->LOW
 252   7                                        P1 |=  0x10; //RTS HIGH
 253   7                                        P1 &= ~0x20; //DTR LOW
 254   7                                        break;
 255   7                                      case 0xff://RTS->HIGH,DTR->HIGH
 256   7                                        P1 |=  0x10; //RTS HIGH
 257   7                                        P1 |=  0x20; //DTR HIGH
 258   7                                        break;
 259   7                                      case 0xbf://RTS->LOW,DTR->HIGH
 260   7                                        P1 &= ~0x10; //RTS LOW
 261   7                                        P1 |=  0x20; //DTR HIGH
 262   7                                        break;
 263   7                                      default:
 264   7                                        break;
 265   7                                  }
 266   6                                  break;
 267   6                              case 0x9a://set baud
 268   6                                  baudFlag0 = UsbSetupBuf->wValueL;
 269   6                                  baudFlag1 = UsbSetupBuf->wValueH;
 270   6                                  if((baudFlag0 == 0x12) && (baudFlag1 == 0x13)){
 271   7                                      baud0 = UsbSetupBuf->wIndexL;
 272   7                                      baud1 = UsbSetupBuf->wIndexH;
 273   7                                      switch (baud0)
 274   7                                      {
 275   8                                          case 0x80:
 276   8                                          {
 277   9                                              switch(baud1)
 278   9                                              {
 279  10                                                  case 0x96://110=0x6e
 280  10                                                     LineCoding[3] = 0x00;
 281  10                                                     LineCoding[2] = 0x00;
 282  10                                                     LineCoding[1] = 0x00;
 283  10                                                     LineCoding[0] = 0x6E;
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 6   

 284  10                                                     break;
 285  10                                                   case 0xd9://300=0x12c
 286  10                                                     LineCoding[3] = 0x00;
 287  10                                                     LineCoding[2] = 0x00;
 288  10                                                     LineCoding[1] = 0x01;
 289  10                                                     LineCoding[0] = 0x2c;
 290  10                                                     break;
 291  10                                                   default:
 292  10                                                     break;
 293  10                                              }
 294   9                                          }
 295   8                                              break;
 296   8                                          case 0x81:
 297   8                                          {
 298   9                                              switch(baud1)
 299   9                                              {
 300  10                                                  case 0x64://600=0x258
 301  10                                                     LineCoding[3] = 0x00;
 302  10                                                     LineCoding[2] = 0x00;
 303  10                                                     LineCoding[1] = 0x02;
 304  10                                                     LineCoding[0] = 0x58;
 305  10                                                     break;
 306  10                                                   case 0xb2://1200=0x4b0
 307  10                                                     LineCoding[3] = 0x00;
 308  10                                                     LineCoding[2] = 0x00;
 309  10                                                     LineCoding[1] = 0x02;
 310  10                                                     LineCoding[0] = 0xb0;
 311  10                                                     break;
 312  10                                                   case 0xd9://2400=0x960
 313  10                                                     LineCoding[3] = 0x00;
 314  10                                                     LineCoding[2] = 0x00;
 315  10                                                     LineCoding[1] = 0x09;
 316  10                                                     LineCoding[0] = 0x60;
 317  10                                                     break;
 318  10                                                   default:
 319  10                                                     break;
 320  10                                              }
 321   9                                          }
 322   8                                              break;
 323   8                                          case 0x82:
 324   8                                          {
 325   9                                              switch(baud1)
 326   9                                                {
 327  10                                                   case 0x64://4800 = 0x12c0
 328  10                                                     LineCoding[3] = 0x00;
 329  10                                                     LineCoding[2] = 0x00;
 330  10                                                     LineCoding[1] = 0x12;
 331  10                                                     LineCoding[0] = 0xc0;
 332  10                                                     break;
 333  10                                                   case 0xb2://9600 = 0x2580
 334  10                                                     LineCoding[3] = 0x00;
 335  10                                                     LineCoding[2] = 0x00;
 336  10                                                     LineCoding[1] = 0x25;
 337  10                                                     LineCoding[0] = 0x80;
 338  10                                                     break;
 339  10                                                   case 0xcc://14400 = 0x3840
 340  10                                                     LineCoding[3] = 0x00;
 341  10                                                     LineCoding[2] = 0x00;
 342  10                                                     LineCoding[1] = 0x38;
 343  10                                                     LineCoding[0] = 0x40;
 344  10                                                     break;
 345  10                                                   case 0xd9://19200=0x4B00
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 7   

 346  10                                                     LineCoding[3] = 0x00;
 347  10                                                     LineCoding[2] = 0x00;
 348  10                                                     LineCoding[1] = 0x4b;
 349  10                                                     LineCoding[0] = 0x00;
 350  10                                                     break;
 351  10                                                   default:
 352  10                                                     break;
 353  10                                                }
 354   9                                          }
 355   8                                              break;
 356   8                                          case 0x83:
 357   8                                          {
 358   9                                              switch(baud1)
 359   9                                              {
 360  10                                                   case 0x64://38400 = 0x9600
 361  10                                                     LineCoding[3] = 0x00;
 362  10                                                     LineCoding[2] = 0x00;
 363  10                                                     LineCoding[1] = 0x96;
 364  10                                                     LineCoding[0] = 0x00;
 365  10                                                     break;
 366  10                                                   case 0x95://56000 = 0xDAC0
 367  10                                                     LineCoding[3] = 0x00;
 368  10                                                     LineCoding[2] = 0x00;
 369  10                                                     LineCoding[1] = 0xDA;
 370  10                                                     LineCoding[0] = 0xC0;
 371  10                                                     break;
 372  10                                                   case 0x98://57600 = 0xE100
 373  10                                                     LineCoding[3] = 0x00;
 374  10                                                     LineCoding[2] = 0x00;
 375  10                                                     LineCoding[1] = 0xE1;
 376  10                                                     LineCoding[0] = 0x00;
 377  10                                                     break;
 378  10                                                   case 0xcc://115200=0x1c200
 379  10                                                     LineCoding[3] = 0x00;
 380  10                                                     LineCoding[2] = 0x01;
 381  10                                                     LineCoding[1] = 0xc2;
 382  10                                                     LineCoding[0] = 0x00;
 383  10                                                     break;
 384  10                                                   case 0xd1://128000=0x1f400
 385  10                                                     LineCoding[3] = 0x00;
 386  10                                                     LineCoding[2] = 0x01;
 387  10                                                     LineCoding[1] = 0xf4;
 388  10                                                     LineCoding[0] = 0x00;
 389  10                                                     break;
 390  10                                                   case 0xe6://230400=0x38400
 391  10                                                     LineCoding[3] = 0x00;
 392  10                                                     LineCoding[2] = 0x03;
 393  10                                                     LineCoding[1] = 0x84;
 394  10                                                     LineCoding[0] = 0x00;
 395  10                                                     break;
 396  10                                                   case 0xe9://256000=0x3e800
 397  10                                                     LineCoding[3] = 0x00;
 398  10                                                     LineCoding[2] = 0x03;
 399  10                                                     LineCoding[1] = 0xe8;
 400  10                                                     LineCoding[0] = 0x00;
 401  10                                                     break;
 402  10                                                   case 0xf3://460800=0x70800
 403  10                                                     LineCoding[3] = 0x00;
 404  10                                                     LineCoding[2] = 0x07;
 405  10                                                     LineCoding[1] = 0x08;
 406  10                                                     LineCoding[0] = 0x00;
 407  10                                                     break;
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 8   

 408  10                                                   case 0xf4://512000=0x7D000
 409  10                                                     LineCoding[3] = 0x00;
 410  10                                                     LineCoding[2] = 0x07;
 411  10                                                     LineCoding[1] = 0xD0;
 412  10                                                     LineCoding[0] = 0x00;
 413  10                                                     break;
 414  10                                                   case 0xf6://600000=0x927C0
 415  10                                                     LineCoding[3] = 0x00;
 416  10                                                     LineCoding[2] = 0x09;
 417  10                                                     LineCoding[1] = 0x27;
 418  10                                                     LineCoding[0] = 0xC0;
 419  10                                                   case 0xf8://750000=0xB71B0
 420  10                                                     LineCoding[3] = 0x00;
 421  10                                                     LineCoding[2] = 0x0B;
 422  10                                                     LineCoding[1] = 0x71;
 423  10                                                     LineCoding[0] = 0xB0;
 424  10                                                     break;
 425  10                                                   default:
 426  10                                                     break;
 427  10                                              }
 428   9                                            }
 429   8                                              break;
 430   8                                          case 0x87:
 431   8                                          {
 432   9                                              switch(baud1)
 433   9                                              {
 434  10                                                  case 0xf3://921600 = 0xE1000 
 435  10                                                     LineCoding[3] = 0x00;
 436  10                                                     LineCoding[2] = 0x0E;
 437  10                                                     LineCoding[1] = 0x10;
 438  10                                                     LineCoding[0] = 0x00;
 439  10                                                    break;
 440  10                                                  default:
 441  10                                                    break;
 442  10                                              }
 443   9                                          }
 444   8                                              break;
 445   8                                            default:
 446   8                                              break;
 447   8                                      }
 448   7                                          Config_Uart1(LineCoding);
 449   7                                  }
 450   6                                break;
 451   6                              default:
 452   6                                  len = 0xFF;                                            /*ÃüÁî²»Ö§³Ö*/         
 453   6                                  break;
 454   6                          }
 455   5                          if ( SetupLen > len )
 456   5                          {
 457   6                              SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 458   6                          }
 459   5                          len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;//±¾´Î´«Êä³¤¶È
 460   5                          memcpy(Ep0Buffer,pDescr,len);                            //¼ÓÔØÉÏ´«Êý¾Ý
 461   5                          SetupLen -= len;
 462   5                          pDescr += len;
 463   5                  
 464   5                      }else                                                             //±ê×¼ÇëÇó
 465   4                      {
 466   5                          switch(SetupReq)                                             //ÇëÇóÂë
 467   5                          {
 468   6                          case USB_GET_DESCRIPTOR:
 469   6                              switch(UsbSetupBuf->wValueH)
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 9   

 470   6                              {
 471   7                              case 1:                                                  //Éè±¸ÃèÊö·û
 472   7                                  pDescr = DevDesc;                                    //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµ
             -Ä»º³åÇø
 473   7                                  len = sizeof(DevDesc);
 474   7                                  break;
 475   7                              case 2:                                                  //ÅäÖÃÃèÊö·û
 476   7                                  pDescr = CfgDesc;                                    //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµ
             -Ä»º³åÇø
 477   7                                  len = sizeof(CfgDesc);
 478   7                                  break;
 479   7                              default:
 480   7                                  len = 0xff;                                          //²»Ö§³ÖµÄÃüÁî»òÕß³ö´í
 481   7                                  break;
 482   7                              }
 483   6                              if ( SetupLen > len )
 484   6                              {
 485   7                                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 486   7                              }
 487   6                              len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;//±¾´Î´«Êä³¤¶È
 488   6                              memcpy(Ep0Buffer,pDescr,len);                            //¼ÓÔØÉÏ´«Êý¾Ý
 489   6                              SetupLen -= len;
 490   6                              pDescr += len;
 491   6                              break;
 492   6                          case USB_SET_ADDRESS:
 493   6                              SetupLen = UsbSetupBuf->wValueL;                         //ÔÝ´æUSBÉè±¸µØÖ·
 494   6                              break;
 495   6                          case USB_GET_CONFIGURATION:
 496   6                              Ep0Buffer[0] = UsbConfig;
 497   6                              if ( SetupLen >= 1 )
 498   6                              {
 499   7                                  len = 1;
 500   7                              }
 501   6                              break;
 502   6                          case USB_SET_CONFIGURATION:
 503   6                              UsbConfig = UsbSetupBuf->wValueL;
 504   6                              break;
 505   6                          case 0x0A:
 506   6                              break;
 507   6                          case USB_CLEAR_FEATURE:                                      //Clear Feature
 508   6                              if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP )// 
             -¶Ëµã
 509   6                              {
 510   7                                  switch( UsbSetupBuf->wIndexL )
 511   7                                  {
 512   8                                  case 0x82:
 513   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 514   8                                      break;
 515   8                                  case 0x02:
 516   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 517   8                                      break;
 518   8                                  case 0x81:
 519   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 520   8                                      break;
 521   8                  
 522   8                                  default:
 523   8                                      len = 0xFF;                                       // ²»Ö§³ÖµÄ¶Ëµã
 524   8                                      break;
 525   8                                  }
 526   7                              }
 527   6                              else
 528   6                              {
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 10  

 529   7                                  len = 0xFF;                                           // ²»ÊÇ¶Ëµã²»Ö§³Ö
 530   7                              }
 531   6                              break;
 532   6                          case USB_SET_FEATURE:                                         /* Set Feature */
 533   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x00 )        /* ÉèÖÃÉè±¸ */
 534   6                              {
 535   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 536   7                                  {
 537   8                                      if( CfgDesc[ 7 ] & 0x20 )
 538   8                                      {
 539   9                                          /* ÉèÖÃ»½ÐÑÊ¹ÄÜ±êÖ¾ */
 540   9                                      }
 541   8                                      else
 542   8                                      {
 543   9                                          len = 0xFF;                                    /* ²Ù×÷Ê§°Ü */
 544   9                                      }
 545   8                                  }
 546   7                                  else
 547   7                                  {
 548   8                                      len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 549   8                                  }
 550   7                              }
 551   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x02 )    /* ÉèÖÃ¶Ëµã */
 552   6                              {
 553   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 554   7                                  {
 555   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 556   8                                      {
 557   9                                      case 0x82:
 558   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 I
             -N STALL */
 559   9                                          break;
 560   9                                      case 0x02:
 561   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 O
             -UT Stall */
 562   9                                          break;
 563   9                                      case 0x81:
 564   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 I
             -N STALL */
 565   9                                          break;
 566   9                                      default:
 567   9                                          len = 0xFF;                                     /* ²Ù×÷Ê§°Ü */
 568   9                                          break;
 569   9                                      }
 570   8                                  }
 571   7                                  else
 572   7                                  {
 573   8                                      len = 0xFF;                                         /* ²Ù×÷Ê§°Ü */
 574   8                                  }
 575   7                              }
 576   6                              else
 577   6                              {
 578   7                                  len = 0xFF;                                             /* ²Ù×÷Ê§°Ü */
 579   7                              } 
 580   6                              break;
 581   6                          case USB_GET_STATUS:
 582   6                              Ep0Buffer[0] = 0x00;
 583   6                              Ep0Buffer[1] = 0x00;
 584   6                              if ( SetupLen >= 2 )
 585   6                              {
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 11  

 586   7                                  len = 2;
 587   7                              }
 588   6                              else
 589   6                              {
 590   7                                  len = SetupLen;
 591   7                              }
 592   6                              break;
 593   6                          default:
 594   6                              len = 0xff;                                                  //²Ù×÷Ê§°Ü
 595   6                              break;
 596   6                          }
 597   5                      }
 598   4                  }
 599   3                  else
 600   3                  {
 601   4                      len = 0xff;                                                          //°ü³¤¶È´íÎó
 602   4                  }
 603   3                  if(len == 0xff)
 604   3                  {
 605   4                      SetupReq = 0xFF;
 606   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 607   4                  }
 608   3                  else if(len <= THIS_ENDP0_SIZE)                                         //ÉÏ´«Êý¾Ý»òÕß×´Ì¬½×¶Î
             -·µ»Ø0³¤¶È°ü
 609   3                  {
 610   4                      UEP0_T_LEN = len;
 611   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·
             -µ»ØÓ¦´ðACK
 612   4                  }
 613   3                  else
 614   3                  {
 615   4                      UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 616   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ
             -»ØÓ¦´ðACK
 617   4                  }
 618   3                  break;
 619   3              case UIS_TOKEN_IN | 0:                                                      //endpoint0 IN
 620   3                  switch(SetupReq)
 621   3                  {
 622   4                  case USB_GET_DESCRIPTOR:
 623   4                      len = SetupLen >= THIS_ENDP0_SIZE ? THIS_ENDP0_SIZE : SetupLen;     //±¾´Î´«Êä³¤¶È
 624   4                      memcpy( Ep0Buffer, pDescr, len );                                   //¼ÓÔØÉÏ´«Êý¾Ý
 625   4                      SetupLen -= len;
 626   4                      pDescr += len;
 627   4                      UEP0_T_LEN = len;
 628   4                      UEP0_CTRL ^= bUEP_T_TOG;                                            //Í¬²½±êÖ¾Î»·­×ª
 629   4                      break;
 630   4                  case USB_SET_ADDRESS:
 631   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 632   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 633   4                      break;
 634   4                  default:
 635   4                      UEP0_T_LEN = 0;                                                      //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕ
             -ßÊÇÇ¿ÖÆÉÏ´«0³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 636   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 637   4                      break;
 638   4                  }
 639   3                  break;
 640   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 641   3                  len = USB_RX_LEN;
 642   3                  if(SetupReq == 0x09)
 643   3                  {
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 12  

 644   4                      if(Ep0Buffer[0])
 645   4                      {
 646   5                          printf("Light on Num Lock LED!\n");
 647   5                      }
 648   4                      else if(Ep0Buffer[0] == 0)
 649   4                      {
 650   5                          printf("Light off Num Lock LED!\n");
 651   5                      }
 652   4                  }
 653   3                  UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 654   3                  UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA0,·µ»ØÓ¦´ðACK
 655   3                  break;
 656   3              default:
 657   3                  break;
 658   3              }
 659   2              UIF_TRANSFER = 0;                                                           //Ð´0Çå¿ÕÖÐ¶Ï
 660   2          }
 661   1          if(UIF_BUS_RST)                                                                 //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»Ö
             -Ð¶Ï
 662   1          {
 663   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 664   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;
 665   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK | UEP_R_RES_ACK;
 666   2              USB_DEV_AD = 0x00;
 667   2              UIF_SUSPEND = 0;
 668   2              UIF_TRANSFER = 0;
 669   2              UIF_BUS_RST = 0;                                                             //ÇåÖÐ¶Ï±êÖ¾
 670   2              Uart_Input_Point = 0;   //Ñ­»·»º³åÇøÊäÈëÖ¸Õë
 671   2              Uart_Output_Point = 0;  //Ñ­»·»º³åÇø¶Á³öÖ¸Õë
 672   2              UartByteCount = 0;      //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 673   2              USBByteCount = 0;       //USB¶ËµãÊÕµ½µÄ³¤¶È
 674   2              UsbConfig = 0;          //Çå³ýÅäÖÃÖµ
 675   2              UpPoint2_Busy = 0;
 676   2          }
 677   1          if (UIF_SUSPEND)                                                                 //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³
             -É
 678   1          {
 679   2              UIF_SUSPEND = 0;
 680   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                             //¹ÒÆð
 681   2              {
 682   3      #ifdef DE_PRINTF
 683   3                  printf( "zz" );                                                          //Ë¯Ãß×´Ì¬
 684   3      #endif
 685   3                  while ( XBUS_AUX & bUART0_TX )
 686   3                  {
 687   4                      ;    //µÈ´ý·¢ËÍÍê³É
 688   4                  }
 689   3                  SAFE_MOD = 0x55;
 690   3                  SAFE_MOD = 0xAA;
 691   3                  WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO;                      //USB»òÕßRXD0/1ÓÐÐ
             -ÅºÅÊ±¿É±»»½ÐÑ
 692   3                  PCON |= PD;                                                                 //Ë¯Ãß
 693   3                  SAFE_MOD = 0x55;
 694   3                  SAFE_MOD = 0xAA;
 695   3                  WAKE_CTRL = 0x00;
 696   3              }
 697   2          }
 698   1          else {                                                                             //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ
             -·¢ÉúµÄÇé¿ö
 699   2              USB_INT_FG = 0xFF;                                                             //ÇåÖÐ¶Ï±êÖ¾
 700   2      //      printf("UnknownInt  N");
 701   2          }
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 13  

 702   1      }
*** WARNING C280 IN LINE 197 OF CDC.C: 'i': unreferenced local variable
 703          /*******************************************************************************
 704          * Function Name  : Uart1_ISR()
 705          * Description    : ´®¿Ú½ÓÊÕÖÐ¶Ïº¯Êý£¬ÊµÏÖÑ­»·»º³å½ÓÊÕ
 706          *******************************************************************************/
 707          void Uart1_ISR(void) interrupt INT_NO_UART1
 708          {
 709   1        if(U1RI)   //ÊÕµ½Êý¾Ý
 710   1        {
 711   2          Receive_Uart_Buf[Uart_Input_Point++] = SBUF1;
 712   2          UartByteCount++;                    //µ±Ç°»º³åÇøÊ£Óà´ýÈ¡×Ö½ÚÊý
 713   2          if(Uart_Input_Point>=UART_REV_LEN)
 714   2            Uart_Input_Point = 0;           //Ð´ÈëÖ¸Õë
 715   2          U1RI =0;    
 716   2        }
 717   1        
 718   1      }
 719          //Ö÷º¯Êý
 720          main()
 721          {
 722   1        UINT8 lenth;
 723   1        UINT8 j = 0;
 724   1        UINT8 Uart_Timeout = 0;
 725   1        UINT8 nowStatus = 0;
 726   1        //P3_DIR_PU=0xFF;
 727   1        P1_DIR_PU=0xFF;
 728   1        P1 &= ~0x10; //RTS LOW
 729   1        P1 &= ~0x20; //DTR LOW
 730   1        //P1 &= ~0x10; //RTS LOW
 731   1        //P1 |=  0x10; //RTS HIGH
 732   1        //P1 &= ~0x20; //DTR LOW
 733   1        //P1 |=  0x20; //DTR HIGH
 734   1        //p1.4RTS
 735   1        //p1.5DTR
 736   1          CfgFsys( );                                                           //CH559Ê±ÖÓÑ¡ÔñÅäÖÃ
 737   1          mDelaymS(5);                                                          //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó 
 738   1          mInitSTDIO( );                                                        //´®¿Ú0,¿ÉÒÔÓÃÓÚµ÷ÊÔ
 739   1        UART1Setup( );                                                        //ÓÃÓÚCDC
 740   1      #ifdef DE_PRINTF
 741   1          printf("start ...\n");
 742   1      #endif  
 743   1      
 744   1          USBDeviceCfg();                                                    
 745   1          USBDeviceEndPointCfg();                                               //¶ËµãÅäÖÃ
 746   1          USBDeviceIntCfg();                                                    //ÖÐ¶Ï³õÊ¼»¯
 747   1          UEP0_T_LEN = 0;
 748   1          UEP1_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 749   1          UEP2_T_LEN = 0;                                                       //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 750   1      
 751   1          while(1)
 752   1          {
 753   2          if(UsbConfig)
 754   2          {
 755   3            if(USBByteCount)   //USB½ÓÊÕ¶ËµãÓÐÊý¾Ý
 756   3            {
 757   4              CH554UART1SendByte(Ep2Buffer[USBBufOutPoint++]);
 758   4              USBByteCount--;
 759   4              if(USBByteCount==0) 
 760   4                UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_ACK;
 761   4            }
 762   3            if(UartByteCount)
C51 COMPILER V9.59.0.0   CDC                                                               03/25/2019 11:00:11 PAGE 14  

 763   3              Uart_Timeout++;
 764   3            if(!UpPoint2_Busy)   //¶Ëµã²»·±Ã¦£¨¿ÕÏÐºóµÄµÚÒ»°üÊý¾Ý£¬Ö»ÓÃ×÷´¥·¢ÉÏ´«£©
 765   3            {
 766   4              lenth = UartByteCount;
 767   4              if(lenth>0)
 768   4              {
 769   5                if(lenth>31 || Uart_Timeout>100)
 770   5                {   
 771   6                  Uart_Timeout = 0;
 772   6                  if(Uart_Output_Point+lenth>UART_REV_LEN)
 773   6                    lenth = UART_REV_LEN-Uart_Output_Point;
 774   6                  UartByteCount -= lenth;     
 775   6                  //Ð´ÉÏ´«¶Ëµã
 776   6                  memcpy(Ep2Buffer+MAX_PACKET_SIZE,&Receive_Uart_Buf[Uart_Output_Point],lenth);
 777   6                  Uart_Output_Point+=lenth;
 778   6                  if(Uart_Output_Point>=UART_REV_LEN)
 779   6                    Uart_Output_Point = 0;            
 780   6                  UEP2_T_LEN = lenth;                                                    //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 781   6                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;            //Ó¦´ðACK
 782   6                  UpPoint2_Busy = 1;
 783   6                }
 784   5              }
 785   4            }
 786   3          }   
 787   2          }
 788   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2291    ----
   CONSTANT SIZE    =    146    ----
   XDATA SIZE       =     97      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     70    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
